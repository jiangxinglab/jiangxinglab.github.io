---
layout : post
title : algorithms
---

## 一、分而治之

### 1.1 归并排序  
```
问题描述：排序一个序列。
    输入：｛a1，a2，.....｝无序序列
    输出：｛...｝有许序列
问题分解：
    原问题：
        排序一组序列；    （T(n)）
    分解子问题：
        把原序列分成均等数量的两部分；    O(c)
    子问题：
        排序一个序列（问题规模是原来的一半）；    （T(n/2)）
    由子问题导出原问题：
        将两个排好序的序列合并成一个排好序的序列。        O(n)
复杂度分析：
    时间复杂度：O（n*log(n)）
        最坏： n*log(n)
        最好： n*log(n)
    空间复杂度：O(n*log(n))
```

### 1.2 快速排序
```
问题描述：排序一个序列。
        输入：｛a1，a2，.....｝无序序列
        输出：｛...｝有许序列
    问题分解：
        原问题：
            排序一个序列；
        分解子问题：
            预处理原问题；找一个元素以他为轴，使处理后它左面的元素小于它，它右面的元素大于它。以这个元素为边界将原问题分解为两个子问题；一个子问题处理其左面的序列；一个子问题处理其右面的序列；    O(n)
        子问题：
            排序一个序列；（这时子问题的规模是不确定的，其处理的序列可能包含n-1个元素，也可能一个元素都没有；这里期望的是每一个子问题的规模是原问题的一半）
        由子问题的解导出原问题的解：
            不用处理；
    复杂度分析：
        时间复杂度：
            最坏：n2
            最好：n*log(n)
            平均：ny 其中，y=1.4左右吧
        空间复杂度分析：O(n)
```

### 1.3 二分查找
```
  问题描述：在｛a1,a2,,,an｝有序序列中查找某个元素。
        输入：待查找的元素key；
        输出：如果key存在输出位置信息i，如果不存在输出-1；
    问题分解：
        原问题：
            在序列中查找元素，其关键字为key
        分解子问题：
            将key与序列中间位置的元素比较。若相等则返回位置信息，如果问题可以分解，小于则在中间元素前面的有序序列中查找，大于则在中间元素后面的有序序列中查找。
        子问题：
            在序列中查找（序列的规模为原问题一样）；
        由子问题的解导出原问题的解：
            子问题的解就是原问题的解；
    复杂度分析：
        时间复杂度：log(n)
        空间复杂度：o(n)
    补充：
        二分查找，觉得它更适合放在分支限界方法中。理由是每次和中间元素比较不成功则减去一支（序列看成一颗二叉查找树）。
```

### 1.4 找出伪币
```
问题描述：
        给你一个装有1 6个硬币的袋子。1 6个硬币中有一个是伪造的，并且那个伪造的硬币比真的硬币要轻一些。你的任务是找出这个伪造的硬币。为了帮助你完成这一任务，将提供一台可用来比较两组硬币重量的仪器，利用这台                    
    仪器，可以知道两组硬币的重量是否相同。
        输入：16枚硬币，其中有一枚为假
        输出：假的那一枚硬币
    任务分解：
        原问题：
            一些硬币有一枚为假的硬币中，找出假的那一枚
        分解子问题：
            如果只有一枚硬币，则这枚为假的，原问题返回；否则将这堆硬币等分然后称重，重量小的那一堆包含假硬币，再在那一堆中查找。
        子问题：
            同源问题，只是问题规模减小到其一半。
        原问题的解：
            子问题的解为原问题的解。
    复杂度分析：
        时间复杂度：O(log(n))
        空间复杂度：O(n)
    出处： 出处：书《数据结构算法与应用-C__语言描述》第十四章
```

### 1.5 金块问题
```
问题描述：
        有一个老板有一袋金块。每个月将有两名雇员会因其优异的表现分别被奖 励一个金块。按规矩，排名第一的雇员将得到袋中最重的金块，排名第二的雇员将得到袋中最轻的金块。根据这种方式，除非有新的金块加入袋中，否则第一名雇员所得到的金块总是比第二名雇员所得到的金块重。如果有新的金块周期性的加入袋中，则每个月都必须找出最轻和最重的金块。假设有一台比较重量的仪器，我们希望用最少的比较次数找出最轻和最重的金块。
        输入：一堆金块
        输出：最大的和最小的
     问题分解：
        原问题：
            在一堆金块中找最大最小的金块
        分解子问题：
            等分成两堆金块
        子问题：
            同原问题，只是规模为其一半
        原问题的解：
            两个子问题的最大金块取大为原问题的最大金块，最小金块取小为原问题的最小金块
    复杂度分析：
        时间复杂度：O(n)
        空间复杂度：O(n)        
    出处：书《数据结构算法与应用-C__语言描述》第十四章
    书中比较有意思的地方：
       假设n= 8。这个袋子被平分为各有4个金块的两个袋子A和B。为了在A中找出最重和最轻的金块，A中的4个金块被分成两组A1和A2。每一组有两个金块，可以用一次比较在A中找出较重的金块HA1和较轻的金块LA1。经过另外一次比较，又能找出 HA 2和LA 2。现在通过比较HA1和HA2，能找出HA；通过LA 1和LA2的比较找出LA。这样，通过4次比较可以找到HA 和LA。同样需要另外4次比较来确定HB 和LB。通过比较HA 和HB（LA 和LB），就能找出所有金块中最重和最轻的。因此，当n= 8时，这种分而治之的方法需要1 0次比较。如果使用程序1 - 3 1，则需要1 3次比较。如果使用程序2 - 2 6和2 - 2 7，则最多需要1 4次比较。
```
