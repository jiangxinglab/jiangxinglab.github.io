---
layout : post
title : algorithms
---

## 一、分而治之

### 1.1 归并排序  
```
问题描述：排序一个序列。
    输入：｛a1，a2，.....｝无序序列
    输出：｛...｝有许序列
问题分解：
    原问题：
        排序一组序列；    （T(n)）
    分解子问题：
        把原序列分成均等数量的两部分；    O(c)
    子问题：
        排序一个序列（问题规模是原来的一半）；    （T(n/2)）
    由子问题导出原问题：
        将两个排好序的序列合并成一个排好序的序列。        O(n)
复杂度分析：
    时间复杂度：O（n*log(n)）
        最坏： n*log(n)
        最好： n*log(n)
    空间复杂度：O(n*log(n))
```

### 1.2 快速排序
```
问题描述：排序一个序列。
        输入：｛a1，a2，.....｝无序序列
        输出：｛...｝有许序列
    问题分解：
        原问题：
            排序一个序列；
        分解子问题：
            预处理原问题；找一个元素以他为轴，使处理后它左面的元素小于它，它右面的元素大于它。以这个元素为边界将原问题分解为两个子问题；一个子问题处理其左面的序列；一个子问题处理其右面的序列；    O(n)
        子问题：
            排序一个序列；（这时子问题的规模是不确定的，其处理的序列可能包含n-1个元素，也可能一个元素都没有；这里期望的是每一个子问题的规模是原问题的一半）
        由子问题的解导出原问题的解：
            不用处理；
    复杂度分析：
        时间复杂度：
            最坏：n2
            最好：n*log(n)
            平均：ny 其中，y=1.4左右吧
        空间复杂度分析：O(n)
```

### 1.3 二分查找
```
  问题描述：在｛a1,a2,,,an｝有序序列中查找某个元素。
        输入：待查找的元素key；
        输出：如果key存在输出位置信息i，如果不存在输出-1；
    问题分解：
        原问题：
            在序列中查找元素，其关键字为key
        分解子问题：
            将key与序列中间位置的元素比较。若相等则返回位置信息，如果问题可以分解，小于则在中间元素前面的有序序列中查找，大于则在中间元素后面的有序序列中查找。
        子问题：
            在序列中查找（序列的规模为原问题一样）；
        由子问题的解导出原问题的解：
            子问题的解就是原问题的解；
    复杂度分析：
        时间复杂度：log(n)
        空间复杂度：o(n)
    补充：
        二分查找，觉得它更适合放在分支限界方法中。理由是每次和中间元素比较不成功则减去一支（序列看成一颗二叉查找树）。
```

### 1.4 找出伪币
```
问题描述：
        给你一个装有1 6个硬币的袋子。1 6个硬币中有一个是伪造的，并且那个伪造的硬币比真的硬币要轻一些。你的任务是找出这个伪造的硬币。为了帮助你完成这一任务，将提供一台可用来比较两组硬币重量的仪器，利用这台                    
    仪器，可以知道两组硬币的重量是否相同。
        输入：16枚硬币，其中有一枚为假
        输出：假的那一枚硬币
    任务分解：
        原问题：
            一些硬币有一枚为假的硬币中，找出假的那一枚
        分解子问题：
            如果只有一枚硬币，则这枚为假的，原问题返回；否则将这堆硬币等分然后称重，重量小的那一堆包含假硬币，再在那一堆中查找。
        子问题：
            同源问题，只是问题规模减小到其一半。
        原问题的解：
            子问题的解为原问题的解。
    复杂度分析：
        时间复杂度：O(log(n))
        空间复杂度：O(n)
    出处： 出处：书《数据结构算法与应用-C__语言描述》第十四章
```

### 1.5 金块问题
```
问题描述：
        有一个老板有一袋金块。每个月将有两名雇员会因其优异的表现分别被奖 励一个金块。按规矩，排名第一的雇员将得到袋中最重的金块，排名第二的雇员将得到袋中最轻的金块。根据这种方式，除非有新的金块加入袋中，否则第一名雇员所得到的金块总是比第二名雇员所得到的金块重。如果有新的金块周期性的加入袋中，则每个月都必须找出最轻和最重的金块。假设有一台比较重量的仪器，我们希望用最少的比较次数找出最轻和最重的金块。
        输入：一堆金块
        输出：最大的和最小的
     问题分解：
        原问题：
            在一堆金块中找最大最小的金块
        分解子问题：
            等分成两堆金块
        子问题：
            同原问题，只是规模为其一半
        原问题的解：
            两个子问题的最大金块取大为原问题的最大金块，最小金块取小为原问题的最小金块
    复杂度分析：
        时间复杂度：O(n)
        空间复杂度：O(n)        
    出处：书《数据结构算法与应用-C__语言描述》第十四章
    书中比较有意思的地方：
       假设n= 8。这个袋子被平分为各有4个金块的两个袋子A和B。为了在A中找出最重和最轻的金块，A中的4个金块被分成两组A1和A2。每一组有两个金块，可以用一次比较在A中找出较重的金块HA1和较轻的金块LA1。经过另外一次比较，又能找出 HA 2和LA 2。现在通过比较HA1和HA2，能找出HA；通过LA 1和LA2的比较找出LA。这样，通过4次比较可以找到HA 和LA。同样需要另外4次比较来确定HB 和LB。通过比较HA 和HB（LA 和LB），就能找出所有金块中最重和最轻的。因此，当n= 8时，这种分而治之的方法需要1 0次比较。如果使用程序1 - 3 1，则需要1 3次比较。如果使用程序2 - 2 6和2 - 2 7，则最多需要1 4次比较。
```

## 二、 动态规划

### 2.1 概述
```
1）和分治法一样，动态规划是通过组合子问题的解而解决整个问题的解；
    2）分治法是将问题分解为一些独立的子问题，递归的求解各子问题，然后合并子问题的解而得到原问题的解
    3）动态规划适合用与子问题不是独立的情况，也就是各个子问题含有公共的子子问题；在这种情况下分治法与要做很多不必要的工作，即重复的求解公共子问题；
    4）动态规划对每一个遇到的子问题只求解一次，将其结果存入表中，而避免每次遇到同样的子问题时重复计算。
动态规划的算法的设计可以分为如下4个步骤：
    1）描述最优解的结构；
    2）递归定义最有解的值；（一般是最优子结构，这种最优子结构是有层次关系的；不然不能进行第三部）
    3）按至底向上的方式计算最优解的值；
    4）由计算的结果构造一个最优解；
```

### 2.2 装配线调
![smiley]({{BASE_PATH}}/img/post/algorithms/Assembly-line-scheduling.png)

```
问题描述：
    略
    输入：略
    输出：略
构造最优子结构：
    描述最有解结构：
        Optimal=重起始点经过地i挑流水线的第j站的最短时间。表示为optimal(i,j)；其中i｛1，2｝，j｛1...n｝
    递归定义最优解的值：
        optimal(1,1)=e1+a(1,1)
        optimal(2,1)=e2+a(2,1)
        optimal(1,j)=min( ( optimal(1,j-1)+a(1,j) ),( optimal(2,j-1)+t(2,j)+a(1,j) ) )       j=｛2...n｝
        optimal(2,j)=min( ( optimal(1,j-1)+t(1,j)+a(2,j) ),( optimal(2,j-1)+a(2,j) ) )
    至底向上计算最优解：
        按递增的顺序计算optimal(i,j)
    由计算的结果构造一个最优解：
        由得到的表够造最优解
复杂度分析：
    时间复杂度：O(n)
    空间复杂度：这个图+O(n)
```

## 三、贪心法

### 3.1 求解过程
```
1）动态规划求解
2）发现并证明贪心策略
```

### 3.2 贪心算法的理论基础——拟阵
```
一个拟阵是一个满足一下条件的序对M=(S,L);
    1）S是一个有穷的集合；
    2）L是S的一个非空子集簇，且满足如下连个性质
        1、B属于L且A包含于B，则A属于L（遗传性质）
        2、A属于L，B属于L，且|A|<|B|,则有某个原书x属于B-A是个A和{x}的并属于L（交换性质）
    定理16.6 某一拟阵中所有的最大独立子集的大小都是相同的。
    引理 16.7（拟阵具有弹性选择性质）假设M=(S,L)是一个具有全函数w的甲醛拟阵，且S被安全之的单调递减顺序排列。色x为S的第一个是{x}独立的元素（即是L中的一个元素）。如果x存在，则纯在S的一个包含x的最优子集。
    引理19.8 设M=(S,L)为任意一个拟阵。如果x是S的任意元素，是的独立子集A的一个扩张，那么x也是空集的一个扩张。
    引理16.9 设M=(S,L)为任意个拟阵，弱国S中的元素不是空集的扩张，那么x也不谁是S的任意独立自己A的一个扩张。
    引理16.10（你正具有最优子结构性质） 设x为S中被作用于甲醛拟阵M={S,L}的GREEDY第一个选择了的元素。找一个包含x的具有最大权值的独立之际的问题，可以规约为找出加权拟阵M'=(S',L')的一个具有最大权值的独立自己问题，此处
                        S'={y属于S|『x，y』属于L}    L'={B包含于S-{x}|B与{x}的并属于L}
其中，M'的全函数为（受限于S‘DE ）M的全换书（称M’为M的由x引起的收缩）
    定理16.11（拟阵上弹性算法的正确性） 如果M=(S,L)的为具有全函数w的甲醛拟阵，则调用GREEDY(M,w)返回一个最优子集。
```

### 3.3 活动选择问题
```
问题描述：在一组活动中选择相互兼容的活动，要求这组相互兼容活动的数目是所有能相互兼容的活动组合中数目最大的。
    动态规划求解：
        描述最优解：
            S(i,j)={ ak | fi<=sk<fk<=sj }
            optimai(i,j)=S(i,j)中相容活动构成的集合中最大的集合
            optimal(i,j)=optinal(i,k)+ak+optimal(k,j)                    其中ak是optimal(i,j)中的一个活动；
            证明：
                设：最优解活动序列为～ak～；
                那么ak前的～必定是S(i,j)相互兼容的互动活动组成的序列；反正发证明：略
                ～必是optimal(i,k);反证法证明：如果不是，矛盾
                同理ak后的～；
        递归定义最优解：
            optimal(i,j)=max{optimal(i,k)+ak+optimal(k,j)}             其中ak是S(i,j)中的一个活动；
            optimal(i,j)=0                                                           S(i,j)=空；
        自底向上求解最优解：
            由j-i的递增顺序求解;
    贪心侧路：
        定理16.1 对于任意非空子问题Sij,设am是Sij中具有最早结束时间的活动：
                                        fm=min{fk:ak属于Sij}
        那么，
            1）活动am在Sij的某个最大兼容活动子集中被使用。
            2）子问题Sim为空，所以原则am将使子问题Smj为唯一可能非空的子问题。
        贪心求解：
            自顶向下：optimal(0,n+1)=a1+optimal(1,n+1)
                                                 =
    复杂度分析：
    时间复杂度：
                1）动态规划：O(n3)
                2）贪心算法：O(n)      
    空间复杂度：
                1）动态规划：O(n2)
                2)  贪心算法：O(n)  
```
