---
layout : post
title : algorithms
---

## 一、分而治之

### 1.1 归并排序  
<pre class="prettyprint lang-scm">
问题描述：排序一个序列。
    输入：｛a1，a2，.....｝无序序列
    输出：｛...｝有许序列
问题分解：
    原问题：
        排序一组序列；    （T(n)）
    分解子问题：
        把原序列分成均等数量的两部分；    O(c)
    子问题：
        排序一个序列（问题规模是原来的一半）；    （T(n/2)）
    由子问题导出原问题：
        将两个排好序的序列合并成一个排好序的序列。        O(n)
复杂度分析：
    时间复杂度：O（n*log(n)）
        最坏： n*log(n)
        最好： n*log(n)
    空间复杂度：O(n*log(n))
</pre>

### 1.2 快速排序
<pre class="prettyprint lang-scm">
问题描述：排序一个序列。
        输入：｛a1，a2，.....｝无序序列
        输出：｛...｝有许序列
    问题分解：
        原问题：
            排序一个序列；
        分解子问题：
            预处理原问题；找一个元素以他为轴，使处理后它左面的元素小于它，它右面的元素大于它。以这个元素为边界将原问题分解为两个子问题；一个子问题处理其左面的序列；一个子问题处理其右面的序列；    O(n)
        子问题：
            排序一个序列；（这时子问题的规模是不确定的，其处理的序列可能包含n-1个元素，也可能一个元素都没有；这里期望的是每一个子问题的规模是原问题的一半）
        由子问题的解导出原问题的解：
            不用处理；
    复杂度分析：
        时间复杂度：
            最坏：n2
            最好：n*log(n)
            平均：ny 其中，y=1.4左右吧
        空间复杂度分析：O(n)
</pre>

### 1.3 二分查找
<pre class="prettyprint lang-scm">
  问题描述：在｛a1,a2,,,an｝有序序列中查找某个元素。
        输入：待查找的元素key；
        输出：如果key存在输出位置信息i，如果不存在输出-1；
    问题分解：
        原问题：
            在序列中查找元素，其关键字为key
        分解子问题：
            将key与序列中间位置的元素比较。若相等则返回位置信息，如果问题可以分解，小于则在中间元素前面的有序序列中查找，大于则在中间元素后面的有序序列中查找。
        子问题：
            在序列中查找（序列的规模为原问题一样）；
        由子问题的解导出原问题的解：
            子问题的解就是原问题的解；
    复杂度分析：
        时间复杂度：log(n)
        空间复杂度：o(n)
    补充：
        二分查找，觉得它更适合放在分支限界方法中。理由是每次和中间元素比较不成功则减去一支（序列看成一颗二叉查找树）。
</pre>

### 1.4 找出伪币
<pre class="prettyprint lang-scm">
    问题描述：
        给你一个装有16个硬币的袋子。16个硬币中有一个是伪造的，并且那个伪造的硬币比真的硬币要轻一些。你的任务是找出这个伪造的币。为了帮助你完成这一任务，将提供一台可用来比较两组硬币重量的仪器，利用这台仪器，可以知道两组硬币的重量是否相同。
        输入：16枚硬币，其中有一枚为假
        输出：假的那一枚硬币
    任务分解：
        原问题：
            一些硬币有一枚为假的硬币中，找出假的那一枚
        分解子问题：
            如果只有一枚硬币，则这枚为假的，原问题返回；否则将这堆硬币等分然后称重，重量小的那一堆包含假硬币，再在那一堆中查找。
        子问题：
            同源问题，只是问题规模减小到其一半。
        原问题的解：
            子问题的解为原问题的解。
    复杂度分析：
        时间复杂度：O(log(n))
        空间复杂度：O(n)
    出处： 出处：书《数据结构算法与应用-C__语言描述》第十四章
</pre>

### 1.5 金块问题
<pre class="prettyprint lang-scm">
    问题描述：
        有一个老板有一袋金块。每个月将有两名雇员会因其优异的表现分别被奖 励一个金块。按规矩，排名第一的雇员将得到袋中最重的金块，排名第二的雇员将得到袋中最轻的金块。根据这种方式，除非有新的金块加入袋中，否则第一名雇员所得到的金块总是比第二名雇员所得到的金块重。如果有新的金块周期性的加入袋中，则每个月都必须找出最轻和最重的金块。假设有一台比较重量的仪器，我们希望用最少的比较次数找出最轻和最重的金块。
        输入：一堆金块
        输出：最大的和最小的
     问题分解：
        原问题：
            在一堆金块中找最大最小的金块
        分解子问题：
            等分成两堆金块
        子问题：
            同原问题，只是规模为其一半
        原问题的解：
            两个子问题的最大金块取大为原问题的最大金块，最小金块取小为原问题的最小金块
    复杂度分析：
        时间复杂度：O(n)
        空间复杂度：O(n)        
    出处：书《数据结构算法与应用-C__语言描述》第十四章
    书中比较有意思的地方：
       假设n= 8。这个袋子被平分为各有4个金块的两个袋子A和B。为了在A中找出最重和最轻的金块，A中的4个金块被分成两组A1和A2。每一组有两个金块，可以用一次比较在A中找出较重的金块HA1和较轻的金块LA1。经过另外一次比较，又能找出 HA 2和LA 2。现在通过比较HA1和HA2，能找出HA；通过LA 1和LA2的比较找出LA。这样，通过4次比较可以找到HA 和LA。同样需要另外4次比较来确定HB 和LB。通过比较HA 和HB（LA 和LB），就能找出所有金块中最重和最轻的。因此，当n= 8时，这种分而治之的方法需要1 0次比较。如果使用程序1 - 3 1，则需要1 3次比较。如果使用程序2 - 2 6和2 - 2 7，则最多需要1 4次比较。
</pre>



## 二、 动态规划

### 2.1 概述
<pre class="prettyprint lang-scm">
    1）和分治法一样，动态规划是通过组合子问题的解而解决整个问题的解；
    2）分治法是将问题分解为一些独立的子问题，递归的求解各子问题，然后合并子问题的解而得到原问题的解
    3）动态规划适合用与子问题不是独立的情况，也就是各个子问题含有公共的子子问题；在这种情况下分治法与要做很多不必要的工作，即重复的求解公共子问题；
    4）动态规划对每一个遇到的子问题只求解一次，将其结果存入表中，而避免每次遇到同样的子问题时重复计算。
动态规划的算法的设计可以分为如下4个步骤：
    1）描述最优解的结构；
    2）递归定义最有解的值；（一般是最优子结构，这种最优子结构是有层次关系的；不然不能进行第三部）
    3）按至底向上的方式计算最优解的值；
    4）由计算的结果构造一个最优解；
</pre>

### 2.2 装配线调度
<!--
![装配线调度]({{BASE_PATH}}/img/post/algorithms/Assembly-line-scheduling.png)
-->

<pre class="prettyprint lang-scm">
问题描述：
    略
    输入：略
    输出：略
构造最优子结构：
    描述最有解结构：
        Optimal=重起始点经过地i挑流水线的第j站的最短时间。表示为optimal(i,j)；其中i｛1，2｝，j｛1...n｝
    递归定义最优解的值：
        optimal(1,1)=e1+a(1,1)
        optimal(2,1)=e2+a(2,1)
        optimal(1,j)=min( ( optimal(1,j-1)+a(1,j) ),( optimal(2,j-1)+t(2,j)+a(1,j) ) )       j=｛2...n｝
        optimal(2,j)=min( ( optimal(1,j-1)+t(1,j)+a(2,j) ),( optimal(2,j-1)+a(2,j) ) )
    至底向上计算最优解：
        按递增的顺序计算optimal(i,j)
    由计算的结果构造一个最优解：
        由得到的表够造最优解
复杂度分析：
    时间复杂度：O(n)
    空间复杂度：这个图+O(n)
</pre>

## 三、贪心法

### 3.1 求解过程
<pre class="prettyprint lang-scm">
1）动态规划求解
2）发现并证明贪心策略
</pre>

### 3.2 贪心算法的理论基础——拟阵
<pre class="prettyprint lang-scm">
一个拟阵是一个满足一下条件的序对M=(S,L);
    1）S是一个有穷的集合；
    2）L是S的一个非空子集簇，且满足如下连个性质
        1、B属于L且A包含于B，则A属于L（遗传性质）
        2、A属于L，B属于L，且|A|<|B|,则有某个原书x属于B-A是个A和{x}的并属于L（交换性质）
    定理16.6 某一拟阵中所有的最大独立子集的大小都是相同的。
    引理 16.7（拟阵具有弹性选择性质）假设M=(S,L)是一个具有全函数w的甲醛拟阵，且S被安全之的单调递减顺序排列。色x为S的第一个是{x}独立的元素（即是L中的一个元素）。如果x存在，则纯在S的一个包含x的最优子集。
    引理19.8 设M=(S,L)为任意一个拟阵。如果x是S的任意元素，是的独立子集A的一个扩张，那么x也是空集的一个扩张。
    引理16.9 设M=(S,L)为任意个拟阵，弱国S中的元素不是空集的扩张，那么x也不谁是S的任意独立自己A的一个扩张。
    引理16.10（你正具有最优子结构性质） 设x为S中被作用于甲醛拟阵M={S,L}的GREEDY第一个选择了的元素。找一个包含x的具有最大权值的独立之际的问题，可以规约为找出加权拟阵M'=(S',L')的一个具有最大权值的独立自己问题，此处
                        S'={y属于S|『x，y』属于L}    L'={B包含于S-{x}|B与{x}的并属于L}
其中，M'的全函数为（受限于S‘DE ）M的全换书（称M’为M的由x引起的收缩）
    定理16.11（拟阵上弹性算法的正确性） 如果M=(S,L)的为具有全函数w的甲醛拟阵，则调用GREEDY(M,w)返回一个最优子集。
</pre>

### 3.3 活动选择问题
<pre class="prettyprint lang-scm">
问题描述：在一组活动中选择相互兼容的活动，要求这组相互兼容活动的数目是所有能相互兼容的活动组合中数目最大的。
    动态规划求解：
        描述最优解：
            S(i,j)={ ak | fi<=sk<fk<=sj }
            optimai(i,j)=S(i,j)中相容活动构成的集合中最大的集合
            optimal(i,j)=optinal(i,k)+ak+optimal(k,j)                    其中ak是optimal(i,j)中的一个活动；
            证明：
                设：最优解活动序列为～ak～；
                那么ak前的～必定是S(i,j)相互兼容的互动活动组成的序列；反正发证明：略
                ～必是optimal(i,k);反证法证明：如果不是，矛盾
                同理ak后的～；
        递归定义最优解：
            optimal(i,j)=max{optimal(i,k)+ak+optimal(k,j)}             其中ak是S(i,j)中的一个活动；
            optimal(i,j)=0                                                           S(i,j)=空；
        自底向上求解最优解：
            由j-i的递增顺序求解;
    贪心侧路：
        定理16.1 对于任意非空子问题Sij,设am是Sij中具有最早结束时间的活动：
                                        fm=min{fk:ak属于Sij}
        那么，
            1）活动am在Sij的某个最大兼容活动子集中被使用。
            2）子问题Sim为空，所以原则am将使子问题Smj为唯一可能非空的子问题。
        贪心求解：
            自顶向下：optimal(0,n+1)=a1+optimal(1,n+1)
                                                 =
    复杂度分析：
    时间复杂度：
                1）动态规划：O(n3)
                2）贪心算法：O(n)      
    空间复杂度：
                1）动态规划：O(n2)
                2)  贪心算法：O(n)  
</pre>

## 四、回溯

### 4.1 概述
<pre class="prettyprint lang-scm">
概述：从某一状态出发，到达他能走到的一个状态然后继续一直走知道不能再走，由不能再走的状态回溯（到其父状态），父状态再选其他状态继续向前，如果都不行再回溯到其父状态。
    1）用来在一组解空间中，查找出满足特定条件的解（和途中的搜索类似，但是有本质的不同；）
    2）回溯的求解步骤：
        1、构造解空间：（通常为n维向量空间）
        2、用一种合适的结构组织解空间（通常为树形结构、网络结构）
        3、用深度优先遍历树，用限界函数去除对于无用子树的遍历。（其整个过程还是严格上的深度优先遍历，只不过有些子树由于没有满足限界条件而没有遍历）
    3）一些性质：
        1、深度优先搜索算法，一般只需要记录O(h)个节点
        2、广度优先搜索算法、，需要保存一层的节点。
        3、节点个个数在O(2n)级别
</pre>

### 4.2 老鼠迷宫
<pre class="prettyprint lang-scm">
 问题描述：查找迷宫中的一条路径，它能成功的走出迷宫
 回溯法求解：
     1）构造皆空间：
         图中入口到出口的所有路径（）
     2）用一种适合的结构组织解空间：
         图，途中每个节点表示当前的状态（老鼠所处的位置等）
     3）搜索解空间、构造减枝条件
         搜索：采用深度优先搜索来搜索目标状态（老鼠处在出口处的那一个节点）
         减枝条件：
             1、下一个要访问的节点是一个活动节点（以前已经访问过的节点），
</pre>

### 4.2 排列问题
<pre class="prettyprint lang-scm">
    问题描述：
        从1到X这X个数字中选出N个，排成一列，相邻两数不能相同，求所有可能的排法。每个数可以选用零次、一次或多次。例如，当N=3、X=3时，排法有12种：121、123、131、132、212、213、231、232、312、313、321、323。
    回溯法求解：
        1）构造解空间；解空间为一个3维向量(x1,x2,x3) xi={1,2,3}
        2)   组织解空间；将解空间表示为一颗满的三叉数，且父节点到子节点有对应的标号{1,2,3};每一层的标号对应向量中的一个值。
        3）深度优先求解：
        4）加入约束条件：
            1、父子节点对应的标号相同，减枝
</pre>

### 4.3 八皇后问题
<!--
![八皇后问题]({{BASE_PATH}}/img/post/algorithms/bahuanghou.png)
-->

<pre class="prettyprint lang-scm">
    问题描述：
        八皇后是数学家高斯提出的趣题，即在国际象棋中8*8的方格的棋盘上如何放置8个皇后，使得8个皇后任何2个不能互相攻击（即不能同一纵列，不能统一横排，不能在45度斜线上）。
    回溯法求解：
        1）构造解空间：
            用8维向量表示解空间，(x1,x2,x3,x4,x5,x6,x7,x8) 其中xi={1,2,3,4,5,6,7,8}
        2)用一种结构组织解空间：
            满八叉8叉树，每一个叶子节点表示一个，向量；第i层到i+1层的坐标对应向量中的第i个元素
        3）采用深度优先搜索算法：
        4）约束条件：
            1、不能同一行：
                用向量表示的解本身就不能同一行；
            2、不能同一列：
                第k个皇后放置的位置不能与前k-1个皇后放置的位置，处于同一列上；减枝；
            3、任意两个皇后不能处在些45度角的同一条斜线上：
                第k个皇后放置的位置，不能与前k-1个皇后处于斜45度角的同一条斜线上（即放置皇后之后k-i != | x[k]-x[i] |）减枝；
            补充：
                2和3个限制条件可以同时判断，其时间复杂度为O(n)
    浮渣度分析：
        时间复杂度：
            整个解空间为：88
            每一次状态检查：O(n)
            树的高度：h=8
        空间复杂度：O(h)
</pre>


## 五、分支定界

### 5.1 概述
<pre class="prettyprint lang-scm">
概述：
    分支定界也是一种通过搜索解空间查找某些解来求解问题；其中对解空间的组织通常采用树型结构，搜索策略采用FIFO方法或优先级方法（这取决于对列的选取）。如果选取FIFO队列搜索策略就成了宽度优先遍历，如果采取优先其队列它的遍历方式是未知的。
    与回溯法相区别：回溯法的遍历的路线是固定的，分支咸界的遍历路线是不固定的。分支限界法加入了启发式函数来减少将要遍历的节点数这是得易与分支限界每次都把当前节点的所有子节点都加入进来的缘故。
    与回溯相比：
        相同：
            思路相同：通过搜索解空间来中的某些节点来求解；
            解空间组织结构：树型（子集树、排列树），图型（）；
        不同：
            搜索策略：回溯是比较固定的深度优先，分支限界可以通过改变其所采用的队列来改变搜索策略
    求解问题的思路：
        1）描述解空间
        2）组织解空间（树型、图型）
        3）搜索解空间（FIFO、优先级队列）
        4）约束条件
定界分支：
    一个上界和一个下界（用来减枝）
</pre>

### 5.2 货船装箱问题
<pre class="prettyprint lang-scm">
    问题描述：(w1,w2,,,wn)，装到一条船上，能装的最大重量；要求货船最多能装w这么重的东东
    分支限界法求解：
        1）描述解空间：n向量(x1,x2,,,xn)，其中xi={0,1};来表示解空间，对应的xi表示货物上船还是没上船
        2）组织解空间：树->满二叉子集树；其中i到i+1层的标志对应向量中的xi分量
        3）搜索策略：
            1、FIFO    :
                1、描述树中节点，NODE{层数,目前的重量}
        4）限界条件：当前总重量<w
</pre>


## 六、数论算法

### 6.1 E欧几里德算法(求两个正整数的最大公约数)
<pre class="prettyprint lang-scm">
E1.（求余数） 将n除m所得的余数为r（0<=r<n）。
E2.（余数为零？） 若余数为0，算法结束，则n即为所求。
E3. （互换） m<--n;n<--r;并返回步骤E1。
</pre>
<!--
![最大公约数]({{BASE_PATH}}/img/post/algorithms/zuidagongyueshu.jpg)
-->


## N、不好分类

### N.1 KMP算法
<pre class="prettyprint lang-scm">
问题描述：在串A，中寻找串B出现的位置。
 问题解空间：（1,(LB),(2,L(B)+1),,,,(L(A)-L(B)+1,L(A))即A中所有连续的长度为L(B)的串都可能是解。这是一种搜索，但是没有找到一种结构能映射上；
 最可能想到的算法：
 A1（最优可能想到的算法）
     A1.1（取得一个解空间的串） s<--A(i...L(B));
     A1.2（查看是否匹配）strcmp(s,B)?yes,no,yes：程序结束，返回i；no：i++回到A1.1步
 KMP算法：
 A2（KMP算法）用上面的方法不好描述暂时用下面的算法描述
</pre>
<pre class="prettyprint lang-c">
int kmp(const chat *A,int LA,const char *B,int LB,int *next){
    int i=0;
    int j=-1;
    for (;i<LA;i++){
        while ( j>-1 && A[i]!=b[j+1] ){
            j=next[j];
        }
        if (A[i]==B[j+1]){
            j++;
        }
       if (j==LB){
            return i;//找到匹配串
        }
  }       
}
void caculateNext(const char *B,int *next){
    int i=0;
    int j=-1;
    B[0]=-1;
    for (;i<LB;i++){
        while ( j>-1 && B[i]!=B[j+1]){
            j=next[j];
        }
        if (B[i]==B[j+1]){
            j=j+1;
        }
        next[i]=j;
        }
    }
}
</pre>

<!--
![KMP]({{BASE_PATH}}/img/post/algorithms/kmp.bmp)
-->

### N.2 Byer-Moore算法
<pre class="prettyprint lang-scm">
问题描述；同上
    问题解空间：同上
    Byer-Moore算法表述：
        从模式串的末尾开始比较，每一次匹配光标向前移动一位，当移动到模式串的第0个位置时表示找到了匹配的串。每一次不匹配时光标向前跳转，当跳出模式串边界时模式串也跟着移动。如果到达串的末尾就说明串中没有和模式串匹配的子串。
        两个表：
            1）CharJump表：记录当前光标字符在模式串中的最右位置，用于表示在查找文本和模式字符串中使用的每个可能的字符。这个表中的每个表象高数我们：需要把装裱想前移动的距离。
            2）重复模式：这个字符之前的所有字符已近匹配，这里用到了已近匹配的信息。他首先在串中查找与串xk+1,xk+2,,,xk+L匹配的最右字串，若找到就设置一种移动方式；若没有找到就求最长前最字串（这里最长前最字串的长度一定小于L，如不然一定存在最由匹配字串），确定另一种移动方式。（两种移动方式的目标都是，模式串移动到匹配的位置，贯标移动到模式串的末尾）
    复杂度分析：
        时间复杂度：
            最坏：O(LA*LB)
            最好：O(LA/LB)
    空间复杂度：O(N)
</pre>
